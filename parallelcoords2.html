<!DOCTYPE html>

<html>

<head>

<title>Parallel coordinates</title>
<link rel="stylesheet" type="text/css" href="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.css">
<script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.js"></script>
<script src="https://syntagmatic.github.io/parallel-coordinates/examples/lib/underscore.js"></script>
<script src="https://syntagmatic.github.io/parallel-coordinates/examples/lib/underscore.math.js"></script>
<script src="https://syntagmatic.github.io/parallel-coordinates/examples/lib/divgrid.js"></script>

</head>

<body>

<div id="pc1" class="parcoords" style="width:1000px;height:300px"></div>
<div id="grid"></div>

<script>

// SCREW IT, JUST EDIT THE CSV FILE TO HAVE THE VARIABLES YOU WANT!!!!

// color-scale for z-scores
var zcolorscale = d3.scale.linear()
  .domain([-2,-0.5,0.5,2])
  .range(["brown", "#999", "#999", "steelblue"])
  .interpolate(d3.interpolateLab);

// load csv file and create the chart
var areaavg = 0;
var fract_davg = 0;
d3.csv("chemo253pc.csv",
function(d) {
  data = d.filter(function(row) {
    var area = +row['AREA'];
    var fract_d = +row['FRACT_D'];
    return 900 <= area && area <= 1000 && fract_d > 0.06;
  });

  console.log(data);

  // ------------
  // PARALLEL COORDINATES
  pc1 = d3.parcoords()("#pc1")
    .data(data)
    .alpha(1)
    .render()
    .reorderable()
    .brushMode("1D-axes")
    .interactive() // command-line mode

  // default z-score colored according to the following variable
  change_color("AREA");

  // click label to activate coloring
  pc1.svg.selectAll(".dimension")
    .on("click", change_color)
    .selectAll(".label")
    //.style("font-size", "14px");

  // calculate means on brushed data
  pc1.on("brush",function(d) {
    var areasum = 0;
    var fract_dsum = 0;
    var data1 = d3.nest()
      .key(function(d) {
        return d.AREA;
      })
      .rollup(function(d) {
        return d3.sum(d, function(g) {
          areasum += +g.AREA;
          fract_dsum += +g.FRACT_D;
        })
      }).entries(d);

    areaavg = areasum / d.length;
    fract_davg = fract_dsum / d.length;
    
  });
  // ------------

});

// ------------
// FUNCTIONS

// fxn to update color
function change_color(dimension) {
  pc1.svg.selectAll(".dimension")
    .style("font-weight", "normal")
    .filter(function(d) { return d == dimension; })
    .style("font-weight", "bold")

  pc1.color(zcolor(pc1.data(),dimension)).render()
}

// fxn to return color function based on plot and dimension
function zcolor(col, dimension) {
  var z = zscore(_(col).pluck(dimension).map(parseFloat))
  return function(d) { return zcolorscale(z(d[dimension])) }
};

// fxn to color by zscore
function zscore(col) {
  var n = col.length,
      mean = _(col).mean(),
      sigma = _(col).stdDeviation();
  return function(d) {
    return (d-mean)/sigma;
  };
};
// ------------

</script>

</body>
</html>
